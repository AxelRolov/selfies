import faulthandler
import random

import pytest
from rdkit.Chem import MolFromSmiles

import selfies as sf

faulthandler.enable()


@pytest.fixture()
def max_len():
    return 1000


@pytest.fixture()
def hard_alphabet():
    """A challenging alphabet of SELFIES symbols.
    """

    alphabet = sf.get_semantic_robust_alphabet()
    alphabet.update([
        '[#Br]', '[#C@@Hexpl]', '[#C@@expl]', '[#C@Hexpl]',
        '[#C@expl]', '[#C]', '[#Cl]', '[#F]', '[#Hexpl]', '[#I]',
        '[#NHexpl]', '[#N]', '[#O]', '[#P]', '[#S]', '[/Br]',
        '[/C@@Hexpl]', '[/C@@expl]', '[/C@Hexpl]', '[/C@expl]', '[/C]',
        '[/Cl]', '[/F]', '[/Hexpl]', '[/I]', '[/NHexpl]', '[/N]',
        '[/O]', '[/P]', '[/S]', '[=Br]', '[=C@@Hexpl]', '[=C@@expl]',
        '[=C@Hexpl]', '[=C@expl]', '[=C]', '[=Cl]', '[=F]', '[=Hexpl]',
        '[=I]', '[=NHexpl]', '[=N]', '[=O]', '[=P]', '[=S]', '[Br]',
        '[Branch1_1]', '[Branch1_2]', '[Branch1_3]', '[Branch2_1]',
        '[Branch2_2]', '[Branch2_3]', '[Branch3_1]', '[Branch3_2]',
        '[Branch3_3]', '[C@@Hexpl]', '[C@@expl]', '[C@Hexpl]',
        '[C@expl]', '[C]', '[Cl]', '[Expl#Ring1]', '[Expl=Ring1]',
        '[F]', '[Hexpl]', '[I]', '[NHexpl]', '[N]', '[O]', '[P]',
        '[Ring1]', '[Ring2]', '[Ring3]', '[S]', '[\\Br]',
        '[\\C@@Hexpl]', '[\\C@@expl]', '[\\C@Hexpl]', '[\\C@expl]',
        '[\\C]', '[\\Cl]', '[\\F]', '[\\Hexpl]', '[\\I]', '[\\NHexpl]',
        '[\\N]', '[\\O]', '[\\P]', '[\\S]', '[epsilon]', '[nop]'
    ])

    return list(alphabet)

def check_alphabet_cache_clear():
    alphabet = sf.get_alphabet_from_selfies()
    default_constraints = sf.get_semantic_constraints()
    new_constraints = default_constraints
    new_constraints['XX']=4
    sf.set_semantic_constraints(new_constraints)
    new_alphabet = sf.get_alphabet_from_selfies()
    assert new_alphabet != alphabet

def test_random_selfies_decoder(trials, max_len, hard_alphabet):
    """Tests if SELFIES that are generated by randomly stringing together
    symbols from the SELFIES alphabet are decoded into valid SMILES.
    """

    sf.set_semantic_constraints()  # re-set alphabet
    alphabet = tuple(hard_alphabet)

    for _ in range(trials):

        # create random SELFIES and decode
        rand_len = random.randint(1, max_len)
        rand_mol = ''.join([random.choice(alphabet) for _ in range(rand_len)])
        smiles = sf.decoder(rand_mol)

        # check if SMILES is valid
        try:
            is_valid = MolFromSmiles(smiles, sanitize=True) is not None
        except Exception:
            is_valid = False

        assert is_valid, \
            "Invalid SMILES {} decoded from {}.".format(smiles, rand_mol)


def test_nop_symbol_decoder(max_len, hard_alphabet):
    """Tests that the '[nop]' symbol is decoded properly, i.e., it is
    always skipped over.
    """

    sf.set_semantic_constraints()

    alphabet = list(hard_alphabet)
    alphabet.remove('[nop]')

    for _ in range(1000):

        # create random SELFIES with and without [nop]
        rand_len = random.randint(1, max_len)
        rand_mol = [random.choice(alphabet) for _ in range(rand_len)]
        rand_mol.extend(['[nop]'] * rand_len)
        random.shuffle(rand_mol)

        with_nops = ''.join(rand_mol)
        without_nops = with_nops.replace('[nop]', '')

        assert sf.decoder(with_nops) == sf.decoder(without_nops)


def test_get_semantic_constraints():
    """Tests selfies.get_semantic_constraints().
    """

    # Getting the constraints does not return aliases
    assert sf.get_semantic_constraints() is not sf.get_semantic_constraints()

    # The appropriate symbols are in the constraints
    constraints = sf.get_semantic_constraints()
    assert '?' in constraints


def test_malformed_smiles_encoder():
    """Tests selfies.encoder() terminates on a malformed SMILES."""
    sf.encoder("C(Cl)(Cl)CC[13C")
    assert True


def test_malformed_selfies_decoder():
    """Tests selfies.decoder() terminates on a malformed SELFIES.
    """
    sf.decoder("[O][=C][O][C][C][C][C][O][N][Branch2_3")
    assert True
